import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'

// Security Headers to check
const SECURITY_HEADERS = [
  'Content-Security-Policy',
  'X-Frame-Options',
  'X-Content-Type-Options',
  'Strict-Transport-Security',
  'X-XSS-Protection',
  'Referrer-Policy',
  'Permissions-Policy'
]

// Advanced SQL Injection test payloads
const SQL_PAYLOADS = [
  "' OR '1'='1",
  "admin'--",
  "' OR 1=1--",
  "1' UNION SELECT NULL--",
  "1' AND 1=0 UNION ALL SELECT 'admin', '81dc9bdb52d04dc20036dbd8313ed055'",
  "admin' or '1'='1'/*",
  "' or 1=1--",
  "' union select null, null, null--",
  "1' WAITFOR DELAY '0:0:5'--",
  "1' AND SLEEP(5)--",
  "'; DROP TABLE users--",
  "' OR EXISTS(SELECT * FROM users)--"
]

// Advanced XSS test payloads
const XSS_PAYLOADS = [
  "<script>alert('XSS')</script>",
  "<img src=x onerror=alert(1)>",
  "<svg/onload=alert(1)>",
  "<iframe src=javascript:alert(1)>",
  "<body onload=alert(1)>",
  "<input onfocus=alert(1) autofocus>",
  "<marquee onstart=alert(1)>",
  "<details open ontoggle=alert(1)>",
  "javascript:alert(1)",
  "<script>alert(String.fromCharCode(88,83,83))</script>",
  "\"><script>alert(1)</script>",
  "';alert(String.fromCharCode(88,83,83))//",
  "<img src=x:alert(1) onerror=eval(src)>",
  "<svg><script>alert(1)</script></svg>"
]

// Path Traversal payloads
const PATH_TRAVERSAL_PAYLOADS = [
  "../../../etc/passwd",
  "..\\..\\..\\windows\\system32\\config\\sam",
  "....//....//....//etc/passwd",
  "..%2F..%2F..%2Fetc%2Fpasswd",
  "..%5c..%5c..%5cwindows%5csystem32%5cconfig%5csam"
]

// Command Injection payloads
const COMMAND_INJECTION_PAYLOADS = [
  "; ls -la",
  "| whoami",
  "& dir",
  "; cat /etc/passwd",
  "| cat /etc/passwd",
  "`whoami`",
  "$(whoami)",
  "; ping -c 10 127.0.0.1"
]

// Common vulnerable files/endpoints
const VULNERABLE_FILES = [
  ".git/config",
  ".env",
  ".env.local",
  ".env.production",
  "config.php",
  "configuration.php",
  "wp-config.php",
  "database.yml",
  ".htaccess",
  "phpinfo.php",
  "info.php",
  "test.php",
  "backup.sql",
  "dump.sql",
  "server-status",
  "server-info",
  ".DS_Store",
  "web.config",
  "composer.json",
  "package.json",
  ".npmrc",
  ".dockerenv"
]

export async function POST(request: NextRequest) {
  const startTime = Date.now()
  
  try {
    const { targetUrl, scanType = 'quick' } = await request.json()

    if (!targetUrl) {
      return NextResponse.json(
        { error: 'Target URL is required' },
        { status: 400 }
      )
    }

    // Validate URL format
    let url: URL
    try {
      url = new URL(targetUrl)
      if (!['http:', 'https:'].includes(url.protocol)) {
        throw new Error('Invalid protocol')
      }
    } catch {
      return NextResponse.json(
        { error: 'Invalid URL format. Use http:// or https://' },
        { status: 400 }
      )
    }

    // Create scan record in database
    const scan = await prisma.websiteScan.create({
      data: {
        targetUrl: url.toString(),
        scanType,
        status: 'scanning',
        scannerIp: request.headers.get('x-forwarded-for') || request.headers.get('x-real-ip') || 'unknown',
        userAgent: request.headers.get('user-agent') || 'BiruCyber Scanner'
      }
    })

    // Start scanning (async)
    performScan(scan.id, url, scanType).catch(console.error)

    return NextResponse.json({
      success: true,
      message: 'Scan initiated',
      scanId: scan.id,
      targetUrl: url.toString(),
      estimatedTime: scanType === 'full' ? '2-5 minutes' : '30-60 seconds'
    })

  } catch (error: any) {
    console.error('Website scan error:', error)
    return NextResponse.json(
      { error: 'Failed to initiate scan: ' + error.message },
      { status: 500 }
    )
  }
}

// Removed in-memory storage - now uses database only

// Advanced technology detection
function detectTechnologies(html: string, headers: any): string[] {
  const technologies: string[] = []
  const htmlLower = html.toLowerCase()
  
  // Server detection
  if (headers.server) technologies.push(`Server: ${headers.server}`)
  if (headers['x-powered-by']) technologies.push(`Powered-By: ${headers['x-powered-by']}`)
  
  // Framework detection
  if (htmlLower.includes('wp-content') || htmlLower.includes('wordpress')) technologies.push('WordPress')
  if (htmlLower.includes('drupal')) technologies.push('Drupal')
  if (htmlLower.includes('joomla')) technologies.push('Joomla')
  if (htmlLower.includes('laravel')) technologies.push('Laravel')
  if (htmlLower.includes('next.js') || htmlLower.includes('_next/')) technologies.push('Next.js')
  if (htmlLower.includes('react')) technologies.push('React')
  if (htmlLower.includes('vue.js') || htmlLower.includes('vue')) technologies.push('Vue.js')
  if (htmlLower.includes('angular')) technologies.push('Angular')
  if (htmlLower.includes('django')) technologies.push('Django')
  if (htmlLower.includes('flask')) technologies.push('Flask')
  if (htmlLower.includes('rails') || htmlLower.includes('ruby')) technologies.push('Ruby on Rails')
  
  // CMS detection
  if (htmlLower.includes('shopify')) technologies.push('Shopify')
  if (htmlLower.includes('wix.com')) technologies.push('Wix')
  if (htmlLower.includes('squarespace')) technologies.push('Squarespace')
  if (htmlLower.includes('magento')) technologies.push('Magento')
  if (htmlLower.includes('prestashop')) technologies.push('PrestaShop')
  
  // JavaScript libraries
  if (htmlLower.includes('jquery')) technologies.push('jQuery')
  if (htmlLower.includes('bootstrap')) technologies.push('Bootstrap')
  if (htmlLower.includes('tailwind')) technologies.push('Tailwind CSS')
  if (htmlLower.includes('material-ui')) technologies.push('Material-UI')
  
  // Analytics & Tracking
  if (htmlLower.includes('google-analytics') || htmlLower.includes('gtag')) technologies.push('Google Analytics')
  if (htmlLower.includes('facebook.com/tr')) technologies.push('Facebook Pixel')
  if (htmlLower.includes('hotjar')) technologies.push('Hotjar')
  
  // CDN detection
  if (htmlLower.includes('cloudflare')) technologies.push('Cloudflare CDN')
  if (htmlLower.includes('akamai')) technologies.push('Akamai CDN')
  if (htmlLower.includes('fastly')) technologies.push('Fastly CDN')
  
  return [...new Set(technologies)] // Remove duplicates
}

// Check for exposed sensitive files
async function checkSensitiveFiles(baseUrl: URL): Promise<any[]> {
  const findings: any[] = []
  
  for (const file of VULNERABLE_FILES.slice(0, 10)) { // Check first 10 to save time
    try {
      const testUrl = new URL(file, baseUrl.toString())
      const response = await fetch(testUrl.toString(), {
        method: 'HEAD',
        signal: AbortSignal.timeout(3000)
      })
      
      if (response.status === 200) {
        findings.push({
          type: 'Exposed Sensitive File',
          severity: 'high',
          description: `Sensitive file accessible: ${file}`,
          recommendation: `Restrict access to ${file} or remove it from public directory`,
          url: testUrl.toString()
        })
      }
    } catch {
      // File not accessible, which is good
    }
  }
  
  return findings
}

// Advanced subdomain detection
async function findSubdomains(domain: string): Promise<string[]> {
  const subdomains = ['www', 'api', 'admin', 'dev', 'staging', 'test', 'mail', 'ftp', 'blog', 'shop']
  const found: string[] = []
  
  for (const sub of subdomains.slice(0, 5)) { // Check first 5 to save time
    try {
      const testUrl = `https://${sub}.${domain}`
      await fetch(testUrl, {
        method: 'HEAD',
        signal: AbortSignal.timeout(2000)
      })
      found.push(`${sub}.${domain}`)
    } catch {
      // Subdomain doesn't exist or not accessible
    }
  }
  
  return found
}

async function performScanNoDB(scanId: string, url: URL, scanType: string) {
  const startTime = Date.now()
  const results: any = {
    vulnerabilities: [],
    securityHeaders: {},
    sslInfo: {},
    technologies: [],
    openPorts: [],
    checks: {
      total: 0,
      passed: 0,
      failed: 0
    }
  }

  try {
    // 1. Check if website is accessible
    results.checks.total++
    try {
      const response = await fetch(url.toString(), {
        method: 'GET',
        headers: {
          'User-Agent': 'BiruCyber Security Scanner/1.0'
        },
        redirect: 'follow',
        signal: AbortSignal.timeout(10000)
      })

      if (response.ok) {
        results.checks.passed++
      }

      // 2. Check Security Headers
      results.checks.total += SECURITY_HEADERS.length
      const headers: any = {}
      
      for (const header of SECURITY_HEADERS) {
        const value = response.headers.get(header)
        headers[header] = value || 'Missing'
        
        if (value) {
          results.checks.passed++
        } else {
          results.checks.failed++
          results.vulnerabilities.push({
            type: 'Missing Security Header',
            name: header,
            severity: 'medium',
            description: `Security header ${header} is not set`,
            recommendation: `Add ${header} header to improve security`
          })
        }
      }
      results.securityHeaders = headers

      // 3. Advanced Technology Detection
      const html = await response.text()
      const detectedTech = detectTechnologies(html, {
        server: response.headers.get('server'),
        'x-powered-by': response.headers.get('x-powered-by'),
        'content-type': response.headers.get('content-type')
      })
      results.technologies = detectedTech

      // 4. Check for CSRF
      results.checks.total++
      if (html.toLowerCase().includes('<form') && !html.toLowerCase().includes('csrf')) {
        results.checks.failed++
        results.vulnerabilities.push({
          type: 'Potential CSRF Vulnerability',
          severity: 'high',
          description: 'Forms detected without visible CSRF protection',
          recommendation: 'Implement CSRF tokens for all state-changing forms'
        })
      } else if (html.toLowerCase().includes('<form')) {
        results.checks.passed++
      }

      // 5. Check for Clickjacking Protection
      results.checks.total++
      const xFrameOptions = response.headers.get('x-frame-options')
      const csp = response.headers.get('content-security-policy')
      if (!xFrameOptions && !csp?.includes('frame-ancestors')) {
        results.checks.failed++
        results.vulnerabilities.push({
          type: 'Clickjacking Vulnerability',
          severity: 'medium',
          description: 'No clickjacking protection detected (missing X-Frame-Options and frame-ancestors CSP)',
          recommendation: 'Add X-Frame-Options: DENY or frame-ancestors directive in CSP'
        })
      } else {
        results.checks.passed++
      }

      // 6. Check for Mixed Content
      results.checks.total++
      if (url.protocol === 'https:' && (html.includes('http://') || html.includes("src='http://") || html.includes('src="http://'))) {
        results.checks.failed++
        results.vulnerabilities.push({
          type: 'Mixed Content',
          severity: 'medium',
          description: 'HTTPS page loading HTTP resources (insecure)',
          recommendation: 'Ensure all resources are loaded over HTTPS'
        })
      } else if (url.protocol === 'https:') {
        results.checks.passed++
      }

      // 7. Check for Autocomplete on sensitive fields
      results.checks.total++
      if (html.toLowerCase().includes('type="password"') && !html.toLowerCase().includes('autocomplete="off"')) {
        results.checks.failed++
        results.vulnerabilities.push({
          type: 'Password Autocomplete Enabled',
          severity: 'low',
          description: 'Password fields allow autocomplete (potential security risk)',
          recommendation: 'Add autocomplete="off" to sensitive input fields'
        })
      } else if (html.toLowerCase().includes('type="password"')) {
        results.checks.passed++
      }

      // Check for SQL errors
      const sqlErrors = ['sql syntax', 'mysql_fetch', 'pg_query', 'sqlite_query', 'odbc_exec']
      results.checks.total++
      for (const error of sqlErrors) {
        if (html.toLowerCase().includes(error)) {
          results.checks.failed++
          results.vulnerabilities.push({
            type: 'SQL Injection - Error Disclosure',
            severity: 'critical',
            description: 'SQL error messages exposed in response',
            recommendation: 'Disable detailed error messages in production'
          })
          break
        }
      }
      if (!results.vulnerabilities.some((v: any) => v.type.includes('SQL'))) {
        results.checks.passed++
      }

      // Check for sensitive info
      results.checks.total++
      const sensitivePatterns = ['password', 'api_key', 'secret', 'token', 'private']
      let foundSensitive = false
      for (const pattern of sensitivePatterns) {
        if (html.toLowerCase().includes(`"${pattern}"`)) {
          results.checks.failed++
          foundSensitive = true
          results.vulnerabilities.push({
            type: 'Sensitive Information Exposure',
            severity: 'high',
            description: `Potential sensitive data found: ${pattern}`,
            recommendation: 'Remove sensitive information from client-side code'
          })
          break
        }
      }
      if (!foundSensitive) results.checks.passed++

    } catch (fetchError: any) {
      results.checks.failed++
      results.vulnerabilities.push({
        type: 'Connection Error',
        severity: 'critical',
        description: `Failed to connect to website: ${fetchError.message}`,
        recommendation: 'Verify website is accessible'
      })
    }

    // 5. SSL/TLS Check
    results.checks.total++
    if (url.protocol === 'https:') {
      results.checks.passed++
      results.sslInfo = {
        enabled: true,
        protocol: 'HTTPS',
        status: 'Secure connection established'
      }
    } else {
      results.checks.failed++
      results.sslInfo = {
        enabled: false,
        protocol: 'HTTP',
        status: 'Insecure connection'
      }
      results.vulnerabilities.push({
        type: 'No SSL/TLS Encryption',
        severity: 'critical',
        description: 'Website is not using HTTPS',
        recommendation: 'Enable SSL/TLS certificate and enforce HTTPS'
      })
    }

    // Calculate security score
    const score = results.checks.total > 0 
      ? Math.round((results.checks.passed / results.checks.total) * 100)
      : 0

    // Determine severity
    const criticalCount = results.vulnerabilities.filter((v: any) => v.severity === 'critical').length
    const highCount = results.vulnerabilities.filter((v: any) => v.severity === 'high').length
    const mediumCount = results.vulnerabilities.filter((v: any) => v.severity === 'medium').length
    
    let overallSeverity = 'low'
    if (criticalCount > 0) overallSeverity = 'critical'
    else if (highCount > 0) overallSeverity = 'high'
    else if (mediumCount > 0) overallSeverity = 'medium'

    // Recommendations
    const recommendations = [
      'Enable HTTPS if not already enabled',
      'Implement all missing security headers',
      'Use Content Security Policy (CSP)',
      'Enable HTTP Strict Transport Security (HSTS)',
      'Regular security audits and penetration testing'
    ]

    // Store result in memory
    const duration = Math.round((Date.now() - startTime) / 1000)
    const scanResult = {
      id: scanId,
      targetUrl: url.toString(),
      status: 'completed',
      vulnerabilities: results.vulnerabilities,
      securityScore: score,
      securityHeaders: results.securityHeaders,
      sslInfo: results.sslInfo,
      technologies: results.technologies,
      scanDuration: duration,
      totalChecks: results.checks.total,
      passedChecks: results.checks.passed,
      failedChecks: results.checks.failed,
      recommendations: recommendations,
      severity: overallSeverity,
      completedAt: new Date().toISOString()
    }

    scanResults.set(scanId, scanResult)

  } catch (error: any) {
    console.error('Scan error:', error)
    scanResults.set(scanId, {
      id: scanId,
      targetUrl: url.toString(),
      status: 'failed',
      errorMessage: error.message
    })
  }
}

async function performScan(scanId: string, url: URL, scanType: string) {
  const startTime = Date.now()
  const results: any = {
    vulnerabilities: [],
    securityHeaders: {},
    sslInfo: {},
    technologies: [],
    openPorts: [],
    checks: {
      total: 0,
      passed: 0,
      failed: 0
    }
  }

  try {
    // 1. Check if website is accessible
    results.checks.total++
    try {
      const response = await fetch(url.toString(), {
        method: 'GET',
        headers: {
          'User-Agent': 'BiruCyber Security Scanner/1.0'
        },
        redirect: 'follow',
        signal: AbortSignal.timeout(10000) // 10 second timeout
      })

      if (response.ok) {
        results.checks.passed++
      }

      // 2. Check Security Headers
      results.checks.total += SECURITY_HEADERS.length
      const headers: any = {}
      
      for (const header of SECURITY_HEADERS) {
        const value = response.headers.get(header)
        headers[header] = value || 'Missing'
        
        if (value) {
          results.checks.passed++
        } else {
          results.checks.failed++
          results.vulnerabilities.push({
            type: 'Missing Security Header',
            name: header,
            severity: 'medium',
            description: `Security header ${header} is not set`,
            recommendation: `Add ${header} header to improve security`
          })
        }
      }
      results.securityHeaders = headers

      // 3. Detect Technologies
      const contentType = response.headers.get('content-type')
      const server = response.headers.get('server')
      const poweredBy = response.headers.get('x-powered-by')
      
      if (server) results.technologies.push(`Server: ${server}`)
      if (poweredBy) results.technologies.push(`Powered By: ${poweredBy}`)
      if (contentType) results.technologies.push(`Content-Type: ${contentType}`)

      // 4. Get response body for further analysis
      const html = await response.text()

      // Check for common vulnerabilities in HTML
      if (html.toLowerCase().includes('<input') && !html.toLowerCase().includes('csrf')) {
        results.checks.total++
        results.checks.failed++
        results.vulnerabilities.push({
          type: 'Potential CSRF Vulnerability',
          severity: 'high',
          description: 'Forms detected without visible CSRF protection',
          recommendation: 'Implement CSRF tokens for all forms'
        })
      }

      // Check for SQL error messages (potential SQL injection)
      const sqlErrors = ['sql syntax', 'mysql_fetch', 'pg_query', 'sqlite_query', 'odbc_exec']
      results.checks.total++
      for (const error of sqlErrors) {
        if (html.toLowerCase().includes(error)) {
          results.checks.failed++
          results.vulnerabilities.push({
            type: 'SQL Injection - Error Disclosure',
            severity: 'critical',
            description: 'SQL error messages exposed in response',
            recommendation: 'Disable detailed error messages in production'
          })
          break
        }
      }
      if (!results.vulnerabilities.some((v: any) => v.type.includes('SQL'))) {
        results.checks.passed++
      }

      // Check for exposed sensitive info
      results.checks.total++
      const sensitivePatterns = ['password', 'api_key', 'secret', 'token', 'private']
      let foundSensitive = false
      for (const pattern of sensitivePatterns) {
        if (html.toLowerCase().includes(`"${pattern}"`)) {
          results.checks.failed++
          foundSensitive = true
          results.vulnerabilities.push({
            type: 'Sensitive Information Exposure',
            severity: 'high',
            description: `Potential sensitive data found: ${pattern}`,
            recommendation: 'Remove sensitive information from client-side code'
          })
          break
        }
      }
      if (!foundSensitive) results.checks.passed++

    } catch (fetchError: any) {
      results.checks.failed++
      results.vulnerabilities.push({
        type: 'Connection Error',
        severity: 'critical',
        description: `Failed to connect to website: ${fetchError.message}`,
        recommendation: 'Verify website is accessible and not blocking automated requests'
      })
    }

    // 5. SSL/TLS Check
    results.checks.total++
    if (url.protocol === 'https:') {
      results.checks.passed++
      results.sslInfo = {
        enabled: true,
        protocol: 'HTTPS',
        status: 'Secure connection established'
      }
    } else {
      results.checks.failed++
      results.sslInfo = {
        enabled: false,
        protocol: 'HTTP',
        status: 'Insecure connection'
      }
      results.vulnerabilities.push({
        type: 'No SSL/TLS Encryption',
        severity: 'critical',
        description: 'Website is not using HTTPS',
        recommendation: 'Enable SSL/TLS certificate and enforce HTTPS'
      })
    }

    // 6. Check for common vulnerable endpoints
    if (scanType === 'full') {
      const vulnerableEndpoints = [
        '/admin',
        '/login',
        '/api',
        '/.git',
        '/.env',
        '/config',
        '/backup',
        '/phpMyAdmin'
      ]

      results.checks.total += vulnerableEndpoints.length
      for (const endpoint of vulnerableEndpoints) {
        try {
          const testUrl = new URL(endpoint, url.toString())
          const resp = await fetch(testUrl.toString(), {
            method: 'HEAD',
            signal: AbortSignal.timeout(5000)
          })

          if (resp.status === 200) {
            results.checks.failed++
            results.vulnerabilities.push({
              type: 'Exposed Sensitive Endpoint',
              severity: 'medium',
              description: `Endpoint ${endpoint} is publicly accessible`,
              recommendation: 'Restrict access to sensitive endpoints'
            })
          } else {
            results.checks.passed++
          }
        } catch {
          results.checks.passed++ // Not accessible = good
        }
      }
    }

    // Calculate security score
    const score = results.checks.total > 0 
      ? Math.round((results.checks.passed / results.checks.total) * 100)
      : 0

    // Determine overall severity
    const criticalCount = results.vulnerabilities.filter((v: any) => v.severity === 'critical').length
    const highCount = results.vulnerabilities.filter((v: any) => v.severity === 'high').length
    const mediumCount = results.vulnerabilities.filter((v: any) => v.severity === 'medium').length
    
    let overallSeverity = 'low'
    if (criticalCount > 0) overallSeverity = 'critical'
    else if (highCount > 0) overallSeverity = 'high'
    else if (mediumCount > 0) overallSeverity = 'medium'

    // Generate recommendations
    const recommendations = [
      'Enable HTTPS if not already enabled',
      'Implement all missing security headers',
      'Use Content Security Policy (CSP)',
      'Enable HTTP Strict Transport Security (HSTS)',
      'Disable detailed error messages in production',
      'Implement rate limiting on sensitive endpoints',
      'Use CSRF tokens for all state-changing operations',
      'Regular security audits and penetration testing'
    ]

    // Update scan record
    const duration = Math.round((Date.now() - startTime) / 1000)
    await prisma.websiteScan.update({
      where: { id: scanId },
      data: {
        status: 'completed',
        vulnerabilities: JSON.stringify(results.vulnerabilities),
        securityScore: score,
        sqlInjection: results.vulnerabilities.some((v: any) => v.type.includes('SQL')),
        xssVulnerable: results.vulnerabilities.some((v: any) => v.type.includes('XSS')),
        brokenAccessControl: results.vulnerabilities.some((v: any) => v.type.includes('Access')),
        securityHeaders: JSON.stringify(results.securityHeaders),
        sslInfo: JSON.stringify(results.sslInfo),
        technologies: JSON.stringify(results.technologies),
        openPorts: JSON.stringify([]), // Placeholder
        scanDuration: duration,
        totalChecks: results.checks.total,
        passedChecks: results.checks.passed,
        failedChecks: results.checks.failed,
        recommendations: JSON.stringify(recommendations),
        severity: overallSeverity,
        completedAt: new Date()
      }
    })

  } catch (error: any) {
    console.error('Scan error:', error)
    await prisma.websiteScan.update({
      where: { id: scanId },
      data: {
        status: 'failed',
        errorMessage: error.message,
        completedAt: new Date()
      }
    })
  }
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const scanId = searchParams.get('scanId')

    if (scanId) {
      // Check memory first (for no-DB scans)
      if (scanResults.has(scanId)) {
        const scan = scanResults.get(scanId)
        return NextResponse.json({
          success: true,
          scan: scan,
          source: 'memory'
        })
      }

      // Check database if Prisma is available
      if (!prisma) {
        return NextResponse.json(
          { error: 'Scan not found and database not connected' },
          { status: 404 }
        )
      }

      // Get specific scan result from database
      const scan = await prisma.websiteScan.findUnique({
        where: { id: scanId }
      })

      if (!scan) {
        return NextResponse.json(
          { error: 'Scan not found' },
          { status: 404 }
        )
      }

      return NextResponse.json({
        success: true,
        scan: {
          ...scan,
          vulnerabilities: scan.vulnerabilities ? JSON.parse(scan.vulnerabilities) : [],
          securityHeaders: scan.securityHeaders ? JSON.parse(scan.securityHeaders) : {},
          sslInfo: scan.sslInfo ? JSON.parse(scan.sslInfo) : {},
          technologies: scan.technologies ? JSON.parse(scan.technologies) : [],
          openPorts: scan.openPorts ? JSON.parse(scan.openPorts) : [],
          recommendations: scan.recommendations ? JSON.parse(scan.recommendations) : []
        },
        source: 'database'
      })
    }

    // If no database, return memory scans
    if (!prisma) {
      const memoryScans = Array.from(scanResults.values()).slice(0, 50)
      return NextResponse.json({
        success: true,
        scans: memoryScans,
        source: 'memory',
        warning: 'Database not connected. Showing recent scans from memory.'
      })
    }

    // Get all scans from database (recent 50)
    const scans = await prisma.websiteScan.findMany({
      orderBy: { createdAt: 'desc' },
      take: 50
    })

    return NextResponse.json({
      success: true,
      scans: scans.map(scan => ({
        id: scan.id,
        targetUrl: scan.targetUrl,
        status: scan.status,
        securityScore: scan.securityScore,
        severity: scan.severity,
        scanDuration: scan.scanDuration,
        createdAt: scan.createdAt,
        completedAt: scan.completedAt
      })),
      source: 'database'
    })

  } catch (error: any) {
    console.error('Get scan error:', error)
    return NextResponse.json(
      { error: 'Failed to retrieve scan' },
      { status: 500 }
    )
  }
}
